\documentclass[11pt, a4paper]{article}
\setlength{\oddsidemargin}{0.5cm}
\setlength{\evensidemargin}{0.5cm}
\setlength{\topmargin}{-1.6cm}
\setlength{\leftmargin}{0.5cm}
\setlength{\rightmargin}{0.5cm}
\setlength{\textheight}{24.00cm} 
\setlength{\textwidth}{15.00cm}
\parindent 0pt
\parskip 5pt
\pagestyle{plain}

\title{Research Proposal}
\author{}
\date{}

\newcommand{\namelistlabel}[1]{\mbox{#1}\hfil}
\newenvironment{namelist}[1]{%1
\begin{list}{}
    {
        \let\makelabel\namelistlabel
        \settowidth{\labelwidth}{#1}
        \setlength{\leftmargin}{1.1\labelwidth}
    }
  }{%1
\end{list}}

\usepackage{graphicx}
\graphicspath{ {../figs/} }

\begin{document}
\maketitle

\begin{namelist}{xxxxxxxxxxxx}
\item[{\bf Title:}]
	Black Box System Model Learning and Verification.
\item[{\bf Author:}]
	Johnathan DiMatteo
\item[{\bf Supervisor:}]
	Professor Sebastian Fischmeister
\item[{\bf Degree:}]
	MMath
\end{namelist}

\section*{Motivation} 
% In this section you should give some background to your
% research area. What is the problem you are tackling, and why is it
% worthwhile solving? Who has already done some work in this area,
% and what have they achieved?

%What is IoT?
%The recent explosion of the Internet of Things (IoT) puts numerous embedded devices at the hands of governments, businesses, and consumers.
%There will be as many as 50 billion IoT devices around the world by 2020 \cite{iotcisco}.
%Their low cost has caused manufacturers to produce and sell them without sufficient security or safety features \cite{iotsec}.
%If action is not taken, vulnerabilities in IoT devices can lead to harm both economically and otherwise.

To enforce security and safety in devices, models must be validated.
Validating a model ensures anomalous states and transitions are corrected to avoid security vulnerabilities.
One proposed method to do this is a process of reverse engineering the system, called \textit{Model Learning}.
Model learning aims to construct blackbox state diagram models of software and hardware systems by providing inputs and observing outputs \cite{modellearning}.
This has been a fundamental research problem studied for decades, but two recent advancements have allowed us to propose a new method.
First, \textit{side channel analysis} has allowed us to study a system's response without the need to open the so called ``black box''.
By treating a device as a black box system, one can monitor the power consumption to provide a non-intrusive approach \cite{seb}.
Traditional modelling tools can introduce timing errors and other anomalies. 
The downside to this approach is the complexity of the response (ie. it is now a time series signal instead of a binary output).
But \textit{machine learning} has opened new data driven approaches for dealing with time series modeling, allowing us to cluster signals to states.
Useful in many areas.
One possible application could be during Hardware in the Loop (HIL) testing to identify unwanted or undocumented functionality.
A well trained model can identify flaws in the design of IoT devices to enforce security and safety.

%By monitoring the trace of the power consumption in response to inputs, a model of the system can be constructed. %Furthermore, the use of the power consumption as an output is a popular form of non-instrusive side channel analysis.

%Through side channel analysis and machine learning a solution can be both practical and feasible.

%has enabled new anomaly detection techniques to identify when the system is in an abnormal state.


%By identifying abnormal states in a specific execution sequence, 
%A model can be constructed to identify the state and state transitions that occur in response to inputs.
%With this model we can then identify when abnormal data occurs, referred to as anomaly detection.

%distances - DTW, pearson

%clustering algorithms - k means, dbscan, gmm

%other - hmm, autoencoders



\section*{Problem Statement} 
%Now state explicitly the hypothesis you aim to
%test. Make references to the items listed in the Reference section
%that back up your arguments for why this is a reasonable
%hypothesis to test, for example the work of Knuth~\cite{knuth}.
%Explain what you expect will be accomplished by undertaking this
%particular project.  Moreover, is it likely to have any other
%applications?

\begin{enumerate}
    \item \textbf{Change Detector}: Given a black box system, determine internal state changes in response to inputs in order to learn the system's behaviour.
    \item \textbf{Input Generator}: Given inputs and knowledge of previous state changes, what should be the next query to the system?
\end{enumerate}

\section*{Method}

\subsection*{System}

\includegraphics[scale=0.5]{Fuzzer.png}

\subsection*{Change Detector}
The Change Detector needs to be able to cluster responses from the system into observed states.
There are several ways to do this.
distance based: measure of how much the signal moved
dtw: define a threshold. larger difference = more confident.

clustering algorithms: do they require us to input no. of states? online learning? confidence?
options: dbscan, k means (dont know many clusters though)
DBSCAN is good, no states required, identifies noise. BUT we have to recalculate with all data points, every time (BUT only do DTW once, ie. 
receive batch of responses, cluster, return yes + msg that triggered it, or no or maybe or more than one + msgs.

Bayesian approach: DETERMINE WHICH CLUSTER OR MAKE A NEW ONE. can eliminate noise manually or just accept it.
for each state, build an expected signal. that way we save out on memory. 
if the expected signal has an extremely high standard deviation ... it might be time to make a new cluster
but we need some way of matching up signals (apparently you can align them using cross correlation, or custom change detection ie. significant change)
compute dtw distance to each expected state signal. (or cluster)
return (current state) or (new state, msg that triggered it)
 
\begin{enumerate}
    \item receive signals
    \item align signals using cross correlation
    \item sample from expected signals (each representing a state) and add those to the group
    \item cluster the group using DBSCAN algorithm
    \item iterate through labels: if a label is in the same group as an expected signal, add it to the signal, update expected signal and state data. Else create a new state.
\end{enumerate}

parameters: eps, const * standard deviation of expected signals for each state,
data: expected signals per state, number of signals per state, standard deviation per state

returns: (state(s), msg(s), all noise) indicating the state change(s) and the message(s) that triggered it.

\subsection*{Input Generator}

needs to know current state.
enumerate through all possibilities at current state (ie. for I2C, write to each bit of one register, send all at once... )
problem: what if we change states and then change again quickly? it would appear as noise. so we need to be careful with noise.
Change Detector returns all states it has observed and the trigger messages.
Log states and trigger messages.
If last state is a new state, repeat. 
Elif (we have seen it before): pick a state we have not been to before.
Else all states have been reached: end.
note: need to verify that all write operations are the same and change with state. have only done so with reads.

step 1: determine active msgs.
step 2: try to change the state: send a bunch of messages while modifying one bit at a time depending on protocol (character for URL, bit for NMAP packets).
step 3: receive response from change detector (yes + msg that triggered it, no, maybe, more than one + msgs)

parameters: protocol specification (json?)
returns: message to send

notes:
L star algorithm: can't because we don't have an oracle that can give us a counterexample, unless we search and depend on our clustering algorithm?
randomization

\section*{Message Sender}
Determined by protocol.
Focus on I2C for now.

\section*{Additional Modules or Functionality}
method to convert states and transitions to mealy machine.
message sender (already implemented for I2C)
focus will be on I2C since system is already in place.

Data model: json? file that stores all states and state transitions.

\end{document}


